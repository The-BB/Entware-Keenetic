# SPDX-License-Identifier: GPL-2.0-only
#
# Copyright (C) 2024 Entware

ACTION="$1"
CALLER="$2"

PATH="/opt/bin:/opt/sbin:/opt/usr/bin:/opt/usr/sbin"

### colors
ansi_bell="\007"
ansi_std="\033[0m"
ansi_red="\033[1;31m"
ansi_green="\033[1;32m"
ansi_yellow="\033[1;33m"
ansi_blue="\033[1;34m"
ansi_magenta="\033[1;35m"
ansi_cyan="\033[1;36m"
ansi_white="\033[1;37m"
ansi_ul="\033[4m"
ansi_blink="\033[5m"
ansi_rev="\033[7m"

### columns
COLUMNS="${COLUMNS:-45}"

### timer
COUNTER=0
LIMIT=${LIMIT:-10}

### sending signal
SIGNAL="${SIGNAL:-HUP}"

### action messages
msg_check() {
  printf "$ansi_white %-${COLUMNS}s $ansi_std" "Checking status $DESC ..."
}

msg_startup_disable() {
  printf "$ansi_white %-${COLUMNS}s $ansi_std" "Disabling autorun $DESC ..."
}

msg_startup_enable() {
  printf "$ansi_white %-${COLUMNS}s $ansi_std" "Enabling autorun $DESC ..."
}

msg_kill() {
  printf "$ansi_white %-${COLUMNS}s $ansi_std" "Killing $DESC ..."
}

msg_reload() {
  printf "$ansi_white %-${COLUMNS}s $ansi_std" "Sending $SIGNAL to $DESC ..."
}

msg_start() {
  printf "$ansi_white %-${COLUMNS}s $ansi_std" "Starting $DESC ..."
}

msg_stop() {
  printf "$ansi_white %-${COLUMNS}s $ansi_std" "Shutting down $DESC ..."
}

### status messages
msg_alive() {
  printf "$ansi_green %-${COLUMNS}s $ansi_std\n" "alive."
}

msg_disabled() {
  printf "$ansi_yellow %-${COLUMNS}s $ansi_std\n" "already disabled."
}

msg_enabled() {
  printf "$ansi_yellow %-${COLUMNS}s $ansi_std\n" "already enabled."
}

msg_dead() {
  printf "$ansi_red %-${COLUMNS}s $ansi_std\n" "dead."
}

msg_done() {
  printf "$ansi_green %-${COLUMNS}s $ansi_std\n" "done."
}

msg_failed() {
  printf "$ansi_red %-${COLUMNS}s $ansi_std\n" "failed."
}

msg_failed_signal() {
  printf "$ansi_red %-${COLUMNS}s $ansi_std\n" "failed (\"$ACTION\" not supported)."
}

msg_running() {
  printf "$ansi_yellow %-${COLUMNS}s $ansi_std\n" "already running."
}

msg_skip() {
  printf "$ansi_yellow %-${COLUMNS}s $ansi_std\n" "skip."
}

msg_startup_disabled() {
  printf "$ansi_cyan %-${COLUMNS}s $ansi_std\n" "autorun disabled."
}

msg_stopped() {
  printf "$ansi_red %-${COLUMNS}s $ansi_std\n" "not running."
}

### get PID
check_prog() {
PS_PID=
PS_STATS=

if [ -f "$PID_FILE" ]; then
  PS_PID="$(cat "$PID_FILE")"
else
  PS_PID="$(pgrep -f "$PROG")"
fi

if { [ -n "$PS_PID" ] && [ "$(readlink "/proc/$PS_PID/exe")" = "$PROG" ]; } || \
   { [ -n "$PS_PID" ] && [ "$(readlink "/proc/$PS_PID/exe")" = "/opt/bin/busybox" ]; }
  then
    PS_STATS=1
  else
    PS_STATS=0
fi
}

do_check() {
  check_prog > /dev/null 2>&1 && msg_check
  if [ "$ENABLED" = "no" ]; then
    msg_startup_disabled && return 0
  elif [ "$ACTION" = "start" ] && [ "$PS_STATS" = 1 ]; then
    msg_running && return 0
  elif [ "$ACTION" = "stop" ] && [ "$PS_STATS" = 0 ]; then
    msg_stopped && return 1
  elif [ "$PS_STATS" = 1 ]; then
    msg_alive && return 0
  else
    msg_dead
    [ -f "$PID_FILE" ] && rm -f "$PID_FILE"
    return 1
  fi
}

do_start() {
  [ "$CRITICAL" != "yes" ] && [ "$CALLER" = "cron" ] && return 7
  [ "$ENABLED" = "yes" ] || return 1
  (
  msg_start
  trap - EXIT HUP INT QUIT TERM TSTP
  $PRECMD > /dev/null 2>&1 &
  #printf "\n\t%s\n" "run: $PREARGS $PROG $ARGS"
  $PREARGS $PROG $ARGS > /dev/null 2>&1 &
  while [ "$COUNTER" -le "$LIMIT" ] && [ -z "$PS_PID" ]; do
    { [ "$PS_STATS" = 1 ] && [ -n "$PS_PID" ]; } || check_prog > /dev/null 2>&1
    sleep 1
    COUNTER="$(( COUNTER + 1 ))"
  done
  $POSTCMD > /dev/null 2>&1 &
  if [ -n "$PS_PID" ]; then
    msg_done
    logger "Started $DESC from $CALLER."
    return 0
  else
    msg_failed
    logger "Failed to start $DESC from $CALLER."
    return 255
  fi
  )
}

do_stop() {
  [ "$ENABLED" = "yes" ] || return 1
  case "$ACTION" in
    stop|restart)
        (
        msg_stop
        trap '' TERM
        kill "$PS_PID" 2>/dev/null
        while [ "$COUNTER" -le "$LIMIT" ] && [ "$PS_STATS" = 1 ]; do
          { [ "$PS_STATS" = 0 ] && [ -z "$PS_PID" ]; } || check_prog > /dev/null 2>&1
          sleep 1
          COUNTER="$(( COUNTER + 1 ))"
        done
        if [ -z "$PS_PID" ] || [ "$PROCS" = "crond" ]; then
            msg_done
            logger "The $DESC service has been stopped."
            rm -f "$PID_FILE"
            return 0
        else
            msg_failed
            logger "Failed to stop $DESC."
            return 255
        fi
        )
    ;;
    kill)
        (
        msg_kill
        if [ "$SKIP_KILL" = 1 ]; then
          msg_skip && return 0
        fi
        trap '' TERM
        kill -9 "$PS_PID" && check_prog > /dev/null 2>&1
        if [ "$PS_STATS" = 0 ]; then
            msg_done
            logger "The $DESC service has been killed."
            rm -f "$PID_FILE"
            return 0
        else
            msg_failed
            logger "Failed to kill $DESC."
            return 255
        fi
        )
    ;;
  esac
}

do_reload() {
  [ "$ENABLED" = "yes" ] || return 1
  msg_reload
  if [ "$SKIP_RELOAD" = 1 ]; then
    msg_skip && return 0
  fi
  (
  trap - HUP INT
  killall -"$SIGNAL" "$PROG" > /dev/null 2>&1
  ) </dev/null 2>&1 1>/opt/tmp/nohup.out &
  sleep 1
  check_prog > /dev/null 2>&1
  if [ -n "$PS_PID" ] && [ "$PS_STATS" = 1 ]; then
    msg_done && return 0
  else
    msg_failed_signal && return 255
  fi
}

do_enable() {
  msg_startup_enable
  if [ "$ENABLED" = "no" ]; then
    sed -i 's,^ENABLED=no,ENABLED=yes,' "$0" && msg_done
  else
    msg_enabled
  fi
  return 0
}

do_disable() {
  msg_startup_disable
  if [ "$ENABLED" = "yes" ]; then
    sed -i 's,^ENABLED=yes,ENABLED=no,' "$0" && msg_done
  else
    msg_disabled
  fi
  return 0
}

do_helps() {
  printf "\n$ansi_white %s $ansi_std\n" "Syntax: $0 [command]"
  printf "\n$ansi_white %s $ansi_std\n\n" "Availabel commands:"
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "start" "Start the service."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "stop" "Stop the service."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "kill" "Kill the service."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "restart" "Restart the service."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "reload" "Reload configuration."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "reconfigure" "See <reload>."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "check" "Service status."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "status" "See <check>."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n" "enable" "Enable service autostart."
  printf "\t$ansi_white %-20s %-${COLUMNS}s $ansi_std\n\n" "disable" "Disable service autostart."
  exit 0
}

case "$ACTION" in
    start)
        do_check || do_start
    ;;
    kill|stop)
        do_check && do_stop
    ;;
    restart)
        do_check > /dev/null && do_stop
        do_check > /dev/null || do_start
    ;;
    check|status)
        do_check
    ;;
    reconfigure|reload)
        ( do_check > /dev/null && do_reload ) || do_start
    ;;
    enable)
        do_enable
    ;;
    disable)
        "$0" stop > /dev/null 2>&1 && do_disable
    ;;
    help)
        do_helps
    ;;
    *)
        printf "$ansi_white %-${COLUMNS}s %-${COLUMNS}s $ansi_std\n" "Usage: $0" "{start|stop|kill|restart|[reconfigure|reload]|[check|status]}"
        exit 1
    ;;
esac

#logger "Leaving ${0##*/}."

exit 0
